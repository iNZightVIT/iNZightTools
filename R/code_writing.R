as_call <- function(x) {
    if (inherits(x, "formula")) {
        stopifnot(length(x) == 2)
        x[[2]]
    } else if (is.atomic(x) || is.name(x) || is.call(x)) {
        x
    } else {
        stop("Unknown input")
    }
}

##' @importFrom methods substituteDirect
interpolate <- function(code, ..., comment = character(),
                        `_env` = parent.frame()) {
    if (length(list(...)) > 0) {
        args <- lapply(list(...), as_call)
        expr <- methods::substituteDirect(as_call(code), args)
    } else {
        expr <- as_call(code)
    }
    res <- eval(expr, `_env`)
    if (length(comment) > 0)
        comment <- paste("##", comment)
    attr(res, "code") <- c(comment, capture.output(expr))
    res
}


##' Used to grab code from a data.frame generated by this package.
##'
##' This is simply a helper function to grab the contents
##' of the `code` attribute contained in the data object.
##'
##' @title Get Data's Code
##' @param data dataset you want to extract the code from
##' @return The code used to generate the data.frame, if available (else NULL) 
##' @author Tom Elliott
##' @export
code <- function(data) return(attr(data, "code"))




replaceVars = function(exp, ...){
  toBeSubbed <- list(...)
  exp_str <- as.character(exp)
  for (i in 1:length(toBeSubbed)){
    exp_str <- gsub(names(toBeSubbed)[i], 
                    toBeSubbed[i], 
                    exp_str, 
                    fixed = TRUE)
  }
  ## NOTE: though we typically don't use return() in R,
  #  it's still good practice 'return' what you want to:
  #  e.g., in this case, either
  #    1. remove assignment (so last line is simply `as.formula(exp_str)`)
  # or 2. write `exp` on the last line (see `interpolate` fn above)
  exp <- as.formula(exp_str)
} 
